<!doctype html><html class="h-full"><head><meta charset="utf-8" /><meta content="ie=edge" http-equiv="X-UA-Compatible" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><title>gaultier.dev</title><link href="../../../images/favicon.ico" rel="icon" type="image/x-icon" /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><script data-website-id="58e0c11c-be1a-4563-a97f-9005d206fd48" defer="" src="https://umami.canonic.fr/script.js"></script><link href="../../../stylesheets/site.css" rel="stylesheet" /><script type="importmap">
  {
  "imports": {
    "@hotwired/stimulus": "https://unpkg.com/@hotwired/stimulus/dist/stimulus.js",
    "tocbot": "https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.30.0/tocbot.min.js",
    "highlight.js": "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/es/highlight.min.js"
  }
}


</script>
<script
  type="module"
  src="../../../javascripts/site.js"
></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.30.0/tocbot.css" rel="stylesheet" /></head><body class="h-full flex flex-col"><header><nav class="p-12 bg-gray-100"><a href="../../../"><span class="font-serif text-2xl font-semibold whitespace-nowrap text-gray-800">gaultier.dev</span></a><div><ul class="flex gap-4 mt-8 text-gray-800"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/links">Links</a></li></ul></div></nav></header><main class="flex-1 p-12"><div data-controller="lol"><article class="prose prose-code:before:hidden prose-code:after:hidden prose-headings:font-serif js-toc-content" data-controller="tocbot highlightjs" data-lol-target="source"><h1 id="optimizing-postgresql-with-partial-indexes-in-rails">Optimizing PostgreSQL with Partial Indexes in Rails</h1>

<p>When our support team complained that abusive messages took too long to load, I dug into the issue and discovered that a partial index could dramatically improve performance. Here&#39;s how I approached the problem and implemented a fix using Rails and PostgreSQL.</p>

<h2 id="the-problem">The Problem</h2>

<blockquote>
<p>We run a messaging app where users can report abusive messages. Our support team regularly reviews flagged content, but the admin page showing unreviewed abusive messages was slow—it took over 20 seconds to load.</p>
</blockquote>

<h2 id="debugging-strategy">Debugging Strategy</h2>

<p>To fix the issue, I followed a standard performance workflow:</p>

<ol>
<li>Confirm there&#39;s a problem</li>
<li>Reproduce it locally</li>
<li>Analyze and experiment with possible fixes</li>
<li>Implement the best one</li>
<li>Measure the result</li>
</ol>

<h2 id="confirm-the-problem">Confirm the Problem</h2>

<p>Logs showed that most of the time was spent on a single SQL query. I <strong>added custom logging</strong> to isolate it and monitor improvements later.
Adding the right metrics early in the process is important — it ensures that any optimization efforts can be validated effectively. </p>

<h2 id="reproduce-locally">Reproduce Locally</h2>

<p>I couldn&#39;t use the production dataset — it was 1TB. So I created a synthetic dataset using <span data-expand="docker_postgres_17" class="expander">Docker</span> and SQL.</p>

<div class='hidden' id='docker_postgres_17'><div class="not-prose">
  <pre><code class="language-bash">docker run --platform linux/arm64 \
  --name postgres17 \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_DB=partial_blog \
  -e POSTGRES_HOST_AUTH_METHOD=trust \
  -p 5417:5432 \
  -d postgres:17

</code></pre>
</div>

<p></div></p>
<div class="not-prose">
  <pre><code class="language-sql">CREATE TABLE messages (
  id SERIAL PRIMARY KEY,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  author_id INTEGER NOT NULL,
  content TEXT NOT NULL,
  is_abusive BOOLEAN NOT NULL,
  is_spam BOOLEAN NOT NULL,
  is_reviewed BOOLEAN NOT NULL,
  is_archived BOOLEAN NOT NULL
);

CREATE INDEX idx_messages_abusive_reviewed
  ON messages (is_abusive, is_spam, is_reviewed, is_archived);

</code></pre>
</div>

<h2 id="generate-realistic-data">Generate Realistic Data</h2>

<p>Initially, I generated 10M messages where:</p>

<ul>
<li>1 in 10,000 were abusive</li>
<li>1 in 100,000 were spam</li>
<li>20% were archived</li>
<li>50% of abusive messages were reviewed</li>
</ul>

<p>With this setup, the query ran fast (30ms), because PostgreSQL found matching rows quickly. But this didn&#39;t reflect production behavior.</p>

<p>So I made the data sparser — 1 abusive message per 1 million rows—and now the query took 250–400ms. Much more realistic.</p>

<h2 id="analyze">Analyze</h2>

<p>PostgreSQL wasn&#39;t using any indexes for the query:</p>
<div class="not-prose">
  <pre><code class="language-sql">SELECT * FROM messages
WHERE is_abusive = TRUE AND is_reviewed = FALSE
ORDER BY created_at DESC LIMIT 5;
</code></pre>
</div>

<p>Why? Because boolean fields have low cardinality, so PostgreSQL skipped existing indexes and performed a full sequential scan.</p>

<h2 id="experimenting-with-indexes">Experimenting with Indexes</h2>

<h3 id="experiment-1-composite-index-on-booleans">Experiment 1: Composite Index on Booleans</h3>
<div class="not-prose">
  <pre><code class="language-sql">CREATE INDEX idx_all_booleans
  ON messages (is_abusive, is_spam, is_reviewed, is_archived);
</code></pre>
</div>

<p>No effect. Postgres still used a sequential scan due to low selectivity.</p>

<h3 id="experiment-2-partial-index">Experiment 2: Partial Index</h3>
<div class="not-prose">
  <pre><code class="language-sql">CREATE INDEX messages_needing_review_idx
  ON messages (id, created_at)
  WHERE is_abusive = TRUE OR is_spam = TRUE;
</code></pre>
</div>

<p>This index only includes rows that actually need reviewing.
Result: Query time dropped to 5ms. That’s a 30x improvement.
PostgreSQL now used an index scan:</p>
<div class="not-prose">
  <pre><code class="language-sql">-&gt; Index Scan using messages_needing_review_idx ...
</code></pre>
</div>

<h2 id="rails-implementation">Rails Implementation</h2>

<p>Rails supports partial indexes natively:</p>
<div class="not-prose">
  <pre><code class="language-rb">add_index :messages, [:id, :created_at],
          name: &quot;messages_needing_review_idx&quot;,
          where: &quot;is_abusive = TRUE OR is_spam = TRUE&quot;,
          algorithm: :concurrently
</code></pre>
</div>

<p>The all magic happens in the <code class="prettyprint">where</code> clause. The index will be written to only when the filter condition is true.</p>

<h2 id="measure-consolidate">Measure &amp; consolidate</h2>

<p>I reran the query in production and confirmed that performance was fixed.</p>

<p>To future-proof this, I added a test to ensure the query planner continues to use our index:</p>
<div class="not-prose">
  <pre><code class="language-ruby">  it &quot;uses the partial index&quot; do
    expect(query.explain).to include(&#39;Index Scan using messages_needing_review_idx&#39;)
  end
</code></pre>
</div>

<p>You might also consider creating a PostgreSQL view to lock the query shape to the index.</p>

<h3 id="a-word-of-caution">A Word of Caution</h3>

<ul>
<li>Partial indexes only help if the filter condition matches exactly.</li>
<li>They also increase write overhead (as any index), so use them only when needed.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>In summary, creating a partial index on my <code class="prettyprint">messages</code> table significantly improved query performance.
This one optimization took our query from 400ms to 5ms.</p>
</article><aside class="hidden sm:block fixed w-1/3 fixed right-0 top-0 bottom-0 bg-gray-800"><div class="h-1/3 bg-gray-800"><div class="js-toc text-white p-8"></div><div class="relative"><div class="peer prose dark:prose-invert" data-lol-target="expansion"></div><div class="absolute top-0 right-0 peer-[:empty]:hidden cursor-pointer" data-action="click->lol#clear"><svg class="size-6" fill="none" stroke="white" stroke-width="1.5" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 18 18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></div></div></aside></div></main><footer><nav class="bg-gray-100 p-12"><div><ul class="flex gap-4 mt-8 text-gray-800"><li><a href="../../../feed.xml">rss</a></li></ul></div></nav></footer></body></html>