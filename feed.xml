<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Quentin Gaultier</title>
    <link>https://gaultier.dev</link>
    <description>Some stuff I work on</description>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Apr 2025 19:46:00 +0000</lastBuildDate>
    <atom:link href="https://gaultier.dev/feed.xml" rel="self" type="application/rss+xml"/>
    <item>
      <guid>https://gaultier.dev/2025/04/08/sidekiq-long-running-job.html</guid>
      <link>https://gaultier.dev/2025/04/08/sidekiq-long-running-job.html</link>
      <title>How to Shield Your App from a Rogue Sidekiq Job</title>
      <pubDate>Tue, 08 Apr 2025 19:46:00 +0000</pubDate>
      <description>&lt;h1 id="how-to-shield-your-app-from-a-rogue-sidekiq-job"&gt;How to Shield Your App from a Rogue Sidekiq Job&lt;/h1&gt;

&lt;p&gt;Sidekiq is great for background processing—but a single misbehaving job (infinite loops, massive data scans, N+1 storms…) can choke your entire pipeline. Restarting Sidekiq only brings the offender right...&lt;/p&gt;</description>
      <content:encoded>
        <![CDATA[<h1 id="how-to-shield-your-app-from-a-rogue-sidekiq-job">How to Shield Your App from a Rogue Sidekiq Job</h1>

<p>Sidekiq is great for background processing—but a single misbehaving job (infinite loops, massive data scans, N+1 storms…) can choke your entire pipeline. Restarting Sidekiq only brings the offender right back. </p>

<p><strong>How do you quarantine a bad job so that it can’t block all your critical work?</strong></p>

<h2 id="a-real-world-incident">A Real-World Incident</h2>

<p>A user submitted a report with a huge date range—no sanitization—and our <code class="prettyprint">ReportJob</code> tried to load terabytes of data. CPU spiked, threads stalled, and everything ground to a halt. Killing and restarting Sidekiq pods simply requeued the same job, and the outage persisted. We needed a way to isolate that single problematic worker.</p>

<h2 id="introducing-a-quarantine-queue">Introducing a “Quarantine” Queue</h2>

<p>The idea is simple: route suspect jobs into a low-concurrency queue serviced by a dedicated Sidekiq process. They’re still retried, but can’t block your high-priority queues.</p>

<h3 id="1-moving-jobs-to-the-quarantine-queue-manually">1. Moving jobs to the quarantine queue manually</h3>

<p>We begin by intercepting job enqueuing and swapping their queue name if they match an ENV-driven “quarantine” list:</p>
<div class="not-prose">
  <pre><code class="language-ruby">class QuarantineMiddleware
  def call(worker, job, queue, redis_pool)
    if ENV.fetch(&#39;QUARANTINED_JOBS&#39;, &#39;&#39;).split(&#39;;&#39;).include?(job[&#39;class&#39;])
      job[&#39;queue&#39;] = &#39;quarantine&#39;
    end
    yield
  end
end

Sidekiq.configure_client do |config|
  config.client_middleware { |chain| chain.add QuarantineMiddleware }
end
</code></pre>
</div>

<p>Set
<code class="prettyprint">
QUARANTINED_JOBS=ReportJob;MegaLoopJob
</code>
to start shunting those jobs into quarantine.</p>

<p><a href="https://www.youtube.com/watch?v=bvdWPGQ8cEA&amp;t=229s">Inspired by this deep-dive on isolating memory-leak jobs.</a>.</p>

<h3 id="2-handling-infinite-loops-on-restart">2. Handling Infinite Loops on Restart</h3>

<p>That client middleware only works on new enqueues; it can’t catch jobs Sidekiq auto-requeues on shutdown. To trap long-running jobs after a pod restart, we use a server middleware:</p>
<div class="not-prose">
  <pre><code class="language-ruby">class LongRunningJobInterceptor
  QUARANTINE_QUEUE = &#39;quarantine&#39;

  def call(worker, job, queue)
    jid = job[&#39;jid&#39;]
    if queue != QUARANTINE_QUEUE &amp;&amp; should_quarantine?(jid)
      # Requeue safely into quarantine
      worker.class.set(queue: QUARANTINE_QUEUE).perform_async(*job[&#39;args&#39;])
      return
    end

    track_start(jid)
    begin
      yield
    rescue Sidekiq::Shutdown
      raise
    ensure
      untrack(jid)
    end
  end

  private

  def should_quarantine?(jid)
    start_time = Sidekiq.redis { |r| r.get(&quot;job:#{jid}:started_at&quot;).to_time }
    (Time.current - start_time) &gt; 1.hour
  end

  def track_start(jid)
    Sidekiq.redis { |r| r.set(&quot;job:#{jid}:started_at&quot;, Time.current) }
  end

  def untrack(jid)
    Sidekiq.redis { |r| r.del(&quot;job:#{jid}:started_at&quot;) }
  end
end

Sidekiq.configure_server do |config|
  config.server_middleware { |chain| chain.add LongRunningJobInterceptor }
end
</code></pre>
</div>

<p>Now, whenever you restart Sidekiq, any job that had been running “too long” automatically moves into your quarantine queue instead of clogging default or critical queues.</p>

<h3 id="3-automating-detection-restart">3. Automating Detection &amp; Restart</h3>

<p>Maintaining a list of known bad actors is helpful, but it still leaves you manually updating ENV variables and restarting processes when things go awry. What if we could automate both detection and remediation of runaway jobs?
Let’s watch for runaway jobs and trigger a graceful process restart.</p>

<h4 id="3-a-why-not-simple-timeouts">3.a Why Not Simple Timeouts?</h4>

<p>Some teams rely on hard timeouts (<code class="prettyprint">Sidekiq::JobTimeout</code>) or even OS-level kills. Unfortunately, these can:</p>

<ul>
<li>Abort mid-transaction, leaving partial writes or queued messages.</li>
<li>Leak resources (DB connections, file handles), causing pool exhaustion.</li>
</ul>

<h4 id="3-b-soft-timeout-monitoring">3.b Soft Timeout Monitoring</h4>

<p>Instead of killing the job mid-flight, let’s signal our orchestrator to restart the entire Sidekiq process, then quarantine repeat offenders on the next run.</p>

<ol>
<li>Track job start times in a shared registry.</li>
<li>Periodically scan for jobs exceeding a configurable threshold (e.g. 2 minutes).</li>
<li>Flag the Sidekiq process as unhealthy (e.g. by touching a file).</li>
<li>Let Kubernetes or Systemd detect the unhealthy marker and recycle the pod or service.</li>
</ol>
<div class="not-prose">
  <pre><code class="language-ruby">class SidekiqMonitor
  HEALTH_FILE = Rails.root.join(&#39;tmp/sidekiq_unhealthy&#39;).freeze

  def self.start
    Thread.new(name: &#39;sidekiq-monitor&#39;) do
      loop do
        RunningJobs.list.each do |job|
          if Time.current - job[:started_at] &gt; 2.minutes
            FileUtils.touch(HEALTH_FILE)
            break
          end
        end
        sleep 1
      end
    end
  end
end

class RunningJobs
  @jobs = Concurrent::Map.new

  def call(worker, job, queue)
    @jobs[Thread.current.object_id] = { jid: job[&#39;jid&#39;], started_at: Time.current }
    yield
  ensure
    @jobs.delete(Thread.current.object_id)
  end

  def self.list
    @jobs.values
  end
end

# In config/initializers/sidekiq.rb
Sidekiq.configure_server do |config|
  config.server_middleware { |chain| chain.add RunningJobs }
  SidekiqMonitor.start
end
</code></pre>
</div>

<ul>
<li><p>Kubernetes (or Systemd) watches <code class="prettyprint">tmp/sidekiq_unhealthy</code> and gracefully restarts the process.</p></li>
<li><p>On restart, our <code class="prettyprint">LongRunningJobInterceptor</code> (from step 2) reroutes any job that previously ran too long into the quarantine queue.</p></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>By combining:</p>

<ol>
<li>Client-side queue rerouting (for future enqueues),</li>
<li>Server-side interception (for jobs requeued on shutdown), and</li>
<li>Automated health monitoring with liveness probes,</li>
</ol>

<p>you can ensure that one rogue Sidekiq job never brings down your entire background pipeline.</p>
]]>
      </content:encoded>
    </item>
    <item>
      <guid>https://gaultier.dev/2025/01/11/how-to-self-ddos-using-nginx-retry-mechanism.html</guid>
      <link>https://gaultier.dev/2025/01/11/how-to-self-ddos-using-nginx-retry-mechanism.html</link>
      <title>Self DDOS-ing with long-running requests and Nginx</title>
      <pubDate>Sat, 11 Jan 2025 17:59:00 +0000</pubDate>
      <description>&lt;h1 id="self-ddos-ing-with-long-running-requests-and-nginx"&gt;Self DDOS-ing with long-running requests and Nginx&lt;/h1&gt;

&lt;p&gt;What if I told you that a single Nginx setting turned a long running request into a self-DoS?
That's exactly what happened on our cluster… Here's a breakdown of what happened.&lt;/p&gt;

&lt;h2 id="the-incident"&gt;The Incident&lt;/h2&gt;

&lt;p&gt;Last...&lt;/p&gt;</description>
      <content:encoded>
        <![CDATA[<h1 id="self-ddos-ing-with-long-running-requests-and-nginx">Self DDOS-ing with long-running requests and Nginx</h1>

<p>What if I told you that a single Nginx setting turned a long running request into a self-DoS?
That&#39;s exactly what happened on our cluster… Here&#39;s a breakdown of what happened.</p>

<h2 id="the-incident">The Incident</h2>

<p>Last week, our monitoring alerted us to a sudden CPU spike on the database node. The culprit: long-running SQL queries triggered when customers generated PDF reports for their dashboards.</p>

<p>Instead of enqueueing these tasks as background jobs, our Rails app processed them synchronously within the request lifecycle. Since report generation can take up to 40 minutes, frustrated users refreshed their browsers after a few seconds—triggering new requests and compounding the load.</p>

<p>Over time, these repeated attempts exhausted both web and database resources, degrading performance cluster-wide.</p>

<h2 id="investigation">Investigation</h2>

<p>I reproduced the issue by generating a report myself. 
After about three minutes, my browser returned a 504 Gateway Timeout. 
Curious about where that timeout lived, I inspected our Nginx Ingress Controller settings and found: </p>
<div class="not-prose">
  <pre><code class="language-nginx">proxy_read_timeout 60s;
proxy_next_upstream_tries 3;
</code></pre>
</div>

<p>Here’s what happened:</p>

<ol>
<li>A request hits Nginx and is proxied to our Rails app.</li>
<li>If no response arrives within 60 seconds, Nginx retries—up to three times.</li>
<li>Meanwhile, the Rails process keeps generating the report for its full duration.</li>
<li>Frustrated users hit refresh, spawning new requests on top of Nginx’s retries.</li>
</ol>

<p>The result? Each report could be processed 3 times per user refresh, quickly overwhelming the cluster.</p>

<h2 id="the-fix">The Fix</h2>

<p>While moving report generation to a background job remains the long-term solution, we needed a quick mitigation to prevent another CPU spike.
We decided to deactivate Nginx’s retry logic temporarily. By reducing tries from three to none, we could immediately cut the redundant load by two-thirds.</p>
<div class="not-prose">
  <pre><code class="language-yaml"># Ingress annotations
nginx.ingress.kubernetes.io/proxy-next-upstream-tries: &quot;1&quot;
</code></pre>
</div>

<h2 id="bonus-a-cautionary-ai-tale">Bonus: a Cautionary AI Tale</h2>

<p>Eager for a quick fix, I turned to ChatGPT for advice. 
It confidently recommended <code class="prettyprint">proxy_next_upstream_tries: 0</code>, which I assumed would disable retries completely.
However, the Nginx docs revealed that setting this value to 0 actually causes Nginx to retry the request infinitely every 60 seconds. The change sent our CPU usage through the roof until I reverted the Helm chart.</p>

<h2 id="next-steps">Next Steps</h2>

<ul>
<li>Asynchronous Processing: Refactor report generation into background jobs with progress notifications.</li>
<li>Timeouts and Circuit Breakers: Implement application-level timeouts to fail fast.</li>
<li>User Feedback: Show a progress indicator and prevent manual refreshes during long-running tasks.</li>
</ul>

<p>This incident reinforced how a small misconfiguration in Nginx can amplify inherent flaws in application design. A careful read of documentation and a temporary tweak saved us from another spike—while we work on the long-term fix.</p>
]]>
      </content:encoded>
    </item>
    <item>
      <guid>https://gaultier.dev/2024/12/31/partial-index.html</guid>
      <link>https://gaultier.dev/2024/12/31/partial-index.html</link>
      <title>Optimizing PostgreSQL with Partial Indexes in Rails</title>
      <pubDate>Tue, 31 Dec 2024 00:00:00 +0000</pubDate>
      <description>&lt;h1 id="optimizing-postgresql-with-partial-indexes-in-rails"&gt;Optimizing PostgreSQL with Partial Indexes in Rails&lt;/h1&gt;

&lt;p&gt;When our support team complained that abusive messages took too long to load, I dug into the issue and discovered that a partial index could dramatically improve performance. Here's how I approached...&lt;/p&gt;</description>
      <content:encoded>
        <![CDATA[<h1 id="optimizing-postgresql-with-partial-indexes-in-rails">Optimizing PostgreSQL with Partial Indexes in Rails</h1>

<p>When our support team complained that abusive messages took too long to load, I dug into the issue and discovered that a partial index could dramatically improve performance. Here&#39;s how I approached the problem and implemented a fix using Rails and PostgreSQL.</p>

<h2 id="the-problem">The Problem</h2>

<blockquote>
<p>We run a messaging app where users can report abusive messages. Our support team regularly reviews flagged content, but the admin page showing unreviewed abusive messages was slow—it took over 20 seconds to load.</p>
</blockquote>

<h2 id="debugging-strategy">Debugging Strategy</h2>

<p>To fix the issue, I followed a standard performance workflow:</p>

<ol>
<li>Confirm there&#39;s a problem</li>
<li>Reproduce it locally</li>
<li>Analyze and experiment with possible fixes</li>
<li>Implement the best one</li>
<li>Measure the result</li>
</ol>

<h2 id="confirm-the-problem">Confirm the Problem</h2>

<p>Logs showed that most of the time was spent on a single SQL query. I <strong>added custom logging</strong> to isolate it and monitor improvements later.
Adding the right metrics early in the process is important — it ensures that any optimization efforts can be validated effectively. </p>

<h2 id="reproduce-locally">Reproduce Locally</h2>

<p>I couldn&#39;t use the production dataset — it was 1TB. So I created a synthetic dataset using <span data-expand="docker_postgres_17" class="expander">Docker</span> and SQL.</p>

<div class='hidden' id='docker_postgres_17'><div class="not-prose">
  <pre><code class="language-bash">docker run --platform linux/arm64 \
  --name postgres17 \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_DB=partial_blog \
  -e POSTGRES_HOST_AUTH_METHOD=trust \
  -p 5417:5432 \
  -d postgres:17

</code></pre>
</div>

<p></div></p>
<div class="not-prose">
  <pre><code class="language-sql">CREATE TABLE messages (
  id SERIAL PRIMARY KEY,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  author_id INTEGER NOT NULL,
  content TEXT NOT NULL,
  is_abusive BOOLEAN NOT NULL,
  is_spam BOOLEAN NOT NULL,
  is_reviewed BOOLEAN NOT NULL,
  is_archived BOOLEAN NOT NULL
);

CREATE INDEX idx_messages_abusive_reviewed
  ON messages (is_abusive, is_spam, is_reviewed, is_archived);

</code></pre>
</div>

<h2 id="generate-realistic-data">Generate Realistic Data</h2>

<p>Initially, I generated 10M messages where:</p>

<ul>
<li>1 in 10,000 were abusive</li>
<li>1 in 100,000 were spam</li>
<li>20% were archived</li>
<li>50% of abusive messages were reviewed</li>
</ul>

<p>With this setup, the query ran fast (30ms), because PostgreSQL found matching rows quickly. But this didn&#39;t reflect production behavior.</p>

<p>So I made the data sparser — 1 abusive message per 1 million rows—and now the query took 250–400ms. Much more realistic.</p>

<h2 id="analyze">Analyze</h2>

<p>PostgreSQL wasn&#39;t using any indexes for the query:</p>
<div class="not-prose">
  <pre><code class="language-sql">SELECT * FROM messages
WHERE is_abusive = TRUE AND is_reviewed = FALSE
ORDER BY created_at DESC LIMIT 5;
</code></pre>
</div>

<p>Why? Because boolean fields have low cardinality, so PostgreSQL skipped existing indexes and performed a full sequential scan.</p>

<h2 id="experimenting-with-indexes">Experimenting with Indexes</h2>

<h3 id="experiment-1-composite-index-on-booleans">Experiment 1: Composite Index on Booleans</h3>
<div class="not-prose">
  <pre><code class="language-sql">CREATE INDEX idx_all_booleans
  ON messages (is_abusive, is_spam, is_reviewed, is_archived);
</code></pre>
</div>

<p>No effect. Postgres still used a sequential scan due to low selectivity.</p>

<h3 id="experiment-2-partial-index">Experiment 2: Partial Index</h3>
<div class="not-prose">
  <pre><code class="language-sql">CREATE INDEX messages_needing_review_idx
  ON messages (id, created_at)
  WHERE is_abusive = TRUE OR is_spam = TRUE;
</code></pre>
</div>

<p>This index only includes rows that actually need reviewing.
Result: Query time dropped to 5ms. That’s a 30x improvement.
PostgreSQL now used an index scan:</p>
<div class="not-prose">
  <pre><code class="language-sql">-&gt; Index Scan using messages_needing_review_idx ...
</code></pre>
</div>

<h2 id="rails-implementation">Rails Implementation</h2>

<p>Rails supports partial indexes natively:</p>
<div class="not-prose">
  <pre><code class="language-rb">add_index :messages, [:id, :created_at],
          name: &quot;messages_needing_review_idx&quot;,
          where: &quot;is_abusive = TRUE OR is_spam = TRUE&quot;,
          algorithm: :concurrently
</code></pre>
</div>

<p>The all magic happens in the <code class="prettyprint">where</code> clause. The index will be written to only when the filter condition is true.</p>

<h2 id="measure-consolidate">Measure &amp; consolidate</h2>

<p>I reran the query in production and confirmed that performance was fixed.</p>

<p>To future-proof this, I added a test to ensure the query planner continues to use our index:</p>
<div class="not-prose">
  <pre><code class="language-ruby">  it &quot;uses the partial index&quot; do
    expect(query.explain).to include(&#39;Index Scan using messages_needing_review_idx&#39;)
  end
</code></pre>
</div>

<p>You might also consider creating a PostgreSQL view to lock the query shape to the index.</p>

<h3 id="a-word-of-caution">A Word of Caution</h3>

<ul>
<li>Partial indexes only help if the filter condition matches exactly.</li>
<li>They also increase write overhead (as any index), so use them only when needed.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>In summary, creating a partial index on my <code class="prettyprint">messages</code> table significantly improved query performance.
This one optimization took our query from 400ms to 5ms.</p>
]]>
      </content:encoded>
    </item>
  </channel>
</rss>
